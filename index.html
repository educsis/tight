<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Unicornio Equilibrista</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      background: #87CEFA;
      font-family: sans-serif;
      overflow: hidden;
      height: 100%;
    }
    canvas {
      display: block;
      margin: auto;
    }
    #score {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 24px;
      font-weight: bold;
      z-index: 1;
    }
    #gameOver {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 32px;
      color: #f55;
      text-align: center;
      display: none;
      z-index: 2;
    }
    #restartBtn {
      position: absolute;
      top: calc(50% + 60px);
      left: 50%;
      transform: translateX(-50%);
      padding: 10px 20px;
      font-size: 18px;
      background: #0af;
      color: white;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      display: none;
      z-index: 3;
    }
    #touchBtn {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 14px 24px;
      font-size: 20px;
      background: #fff;
      color: #333;
      border-radius: 30px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2);
      border: none;
      z-index: 4;
    }
  </style>
</head>
<body>
  <div id="score">Puntos: 0</div>
  <div id="gameOver">üíÄ<br/><span id="finalScore">0</span></div>
  <button id="restartBtn">Reintentar</button>
  <button id="touchBtn">TOCAR ü¶Ñ</button>
  <canvas id="game"></canvas>

  <audio id="bgm" src="race.mp3" loop></audio>
  <audio id="loseSound" src="lose.mp3"></audio>
  <audio id="coinSound" src="coin.mp3"></audio>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const gameOverDisplay = document.getElementById('gameOver');
    const restartBtn = document.getElementById('restartBtn');
    const finalScoreEl = document.getElementById('finalScore');
    const touchBtn = document.getElementById('touchBtn');

    const bgm = document.getElementById('bgm');
    const loseSound = document.getElementById('loseSound');
    const coinSound = document.getElementById('coinSound');
    let soundStarted = false;

    const EMOJI_SIZE = 64;
    let ROPE_Y;
    let PLAYER_X;

    let score, speed, enemies, coins, gameOver, player;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      ROPE_Y = canvas.height / 2;
      PLAYER_X = canvas.width * 0.15;
    }

    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function startSound() {
      if (!soundStarted) {
        soundStarted = true;
        bgm.currentTime = 0;
        bgm.play();
      }
    }

    function init() {
      score = 0;
      speed = 4;
      enemies = [];
      coins = [];
      gameOver = false;

      player = {
        x: PLAYER_X,
        flipped: false,

        update() {
          this.y = this.flipped
            ? ROPE_Y + EMOJI_SIZE / 2
            : ROPE_Y - EMOJI_SIZE / 2;
        },

        draw() {
          this.update();
          ctx.save();
          ctx.translate(this.x, this.y);
            ctx.scale(-1, 1);
          ctx.font = `${EMOJI_SIZE}px serif`;
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText("ü¶Ñ", 0, 0);
          ctx.restore();
        }
      };

      gameOverDisplay.style.display = 'none';
      restartBtn.style.display = 'none';
      touchBtn.style.display = 'block';
      requestAnimationFrame(updateGame);
    }

    function handleFlip() {
      startSound();
      if (!gameOver) {
        player.flipped = !player.flipped;
      }
    }

    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space') handleFlip();
    });

    canvas.addEventListener('touchstart', handleFlip);
    canvas.addEventListener('mousedown', handleFlip);
    touchBtn.addEventListener('click', handleFlip);

    restartBtn.addEventListener('click', () => {
      init();
    });

    function spawnEnemy() {
      const fromTop = Math.random() < 0.5;
      enemies.push({
        x: canvas.width,
        y: fromTop ? ROPE_Y - EMOJI_SIZE : ROPE_Y + EMOJI_SIZE,
        fromTop,
        passed: false
      });
    }

    function spawnCoin() {
      const flipped = Math.random() < 0.5;
      const y = flipped ? ROPE_Y + EMOJI_SIZE : ROPE_Y - EMOJI_SIZE;

      const safeDistance = 80;
      const tooClose = enemies.some(enemy =>
        Math.abs(enemy.x - canvas.width) < safeDistance &&
        Math.abs(enemy.y - y) < safeDistance
      );

      if (!tooClose) {
        coins.push({
          x: canvas.width,
          y: y,
          flipped,
          collected: false
        });
      }
    }

    function drawEmoji(emoji, x, y, size) {
      ctx.font = `${size}px serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(emoji, x, y);
    }

    function drawRope() {
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, ROPE_Y);
      ctx.lineTo(canvas.width, ROPE_Y);
      ctx.stroke();
    }

    function endGame() {
      gameOver = true;
      bgm.pause();
      loseSound.currentTime = 0;
      loseSound.play();
      finalScoreEl.innerText = score;
      gameOverDisplay.style.display = 'block';
      restartBtn.style.display = 'block';
      touchBtn.style.display = 'none';
    }

    function updateGame() {
      if (gameOver) return;

      ctx.fillStyle = '#87CEFA';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawRope();
      player.draw();

      enemies.forEach(enemy => {
        enemy.x -= speed;
        drawEmoji("üíÄ", enemy.x, enemy.y, EMOJI_SIZE);

        if (
          Math.abs(enemy.x - player.x) < 32 &&
          ((enemy.fromTop && !player.flipped) || (!enemy.fromTop && player.flipped))
        ) {
          endGame();
        }

        if (!enemy.passed && enemy.x + EMOJI_SIZE < player.x) {
          score += 1;
          enemy.passed = true;
        }
      });

      coins.forEach(coin => {
        coin.x -= speed;
        drawEmoji("‚≠ê", coin.x, coin.y, EMOJI_SIZE);

        if (
          !coin.collected &&
          Math.abs(coin.x - player.x) < 32 &&
          ((coin.flipped && player.flipped) || (!coin.flipped && !player.flipped))
        ) {
          score += 5;
          coin.collected = true;
          coinSound.currentTime = 0;
          coinSound.play();
        }
      });

      enemies = enemies.filter(e => e.x + EMOJI_SIZE > 0);
      coins = coins.filter(c => c.x + EMOJI_SIZE > 0 && !c.collected);

      speed = 4 + Math.floor(score / 10);
      scoreDisplay.innerText = `Puntos: ${score}`;

      requestAnimationFrame(updateGame);
    }

    setInterval(() => { if (!gameOver) spawnEnemy(); }, 1200);
    setInterval(() => { if (!gameOver) spawnCoin(); }, 1500);

    init();
  </script>
</body>
</html>
